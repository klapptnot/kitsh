#!/usr/bin/bash
# ðŸ”— https://github.com/klapptnot/bash.sh
# SPDX-License-Identifier: AGPL-3.0-or-later
# Copyright (c) 2025-present Klapptnot

include logger.sh
include str_escape.sh
include xml_unescape.sh
include url_params.sh
include load_conf.sh
include barg.sh

# shellcheck disable=SC2034
function main {
  barg::parse "${@}" << BARG
  #[always]
  meta {
    summary: 'Command line tool for Google Search'
    spare_args_var: 'GOOSE_QUERY'
    spare_args_required: true
    help_enabled: true
    show_defaults: true
  }

  commands {list: "Show all presets and exit"}

  @ t/timeout :num 5 => GOOSE_TIMEOUT "Number of seconds to wait for response"
  @ T/tries :int 5 => GOOSE_TRIES "Number of attempts to search Google"
  @ c/cookies :str => GOOSE_COOKIES "Cookies to send with the request"
  @ u/user-agent :str "Mozilla/5.0 (X11; Linux x86_64; rv:132.0) Gecko/20100101 Firefox/132.0" => GOOSE_USER_AGENT "User-agent to send with the request"
  @ a/amount :int 10 => GOOSE_RESULT_AMOUNT "Number of results to return"
  @ s/skip :int 0 => GOOSE_RESULT_START "Number of results skipped"
  @ p/preset :str => GOOSE_PRESET "Use preset query format"
  @ C/command :strs => GOOSE_LAUNCH_WITH "Run command with each URL as params"
  @ j/json :flag => GOOSE_JSON_OUTPUT "Output results in JSON format"
    m/monochrome :flag => GOOSE_MONOCROME "Disable color output"
  @ L/logger :int 4 => LOGGER_LEVEL "Logger verbosity level, 0 to disable logs"
BARG
  barg::unload

  declare -A GOOSE_CONFIG
  load_conf GOOSE_CONFIG ~/.config/_/goose.conf
  local preset_file="${GOOSE_CONFIG[preset_file]/#~/"${HOME}"}"

  if [ "${BARG_SUBCOMMAND}" == 'list' ]; then
    if [ -z "${preset_file}" ]; then
      log e 'No preset file defined. Add `preset_file: <path>` to ~/.config/_/goose.conf'
      return 1
    fi
    if [ ! -f "${preset_file}" ]; then
      log e 'Failed to load presets: no such file %s' "${preset_file}"
      return 1
    fi
    mapfile -t names < <(grep -oP '^\w+' "${preset_file}")
    mapfile -t presets < <(grep -oP '(?<=: ).*$' "${preset_file}")
    for ((i = 0; i < ${#presets[@]}; i++)); do
      if [[ -t 1 ]] && ! ${GOOSE_MONOCROME}; then
        printf '\x1b[38;2;255;169;140m- Name: \x1b[38;2;255;232;184m%s\n' "${names[i]}"
        printf '  \x1b[38;2;195;79;230mFormat: \x1b[38;2;189;147;249m%s\x1b[0m\n' "${presets[i]}"
      else
        printf -- '- Name: %s\n  Format: %s\n' "${names[i]}" "${presets[i]}"
      fi
    done
    return
  fi

  {
    [[ -z "${BARG_ARGV_TABLE[GOOSE_TIMEOUT]}" && -n "${GOOSE_CONFIG[timeout]}" ]] \
      && GOOSE_TIMEOUT="${GOOSE_CONFIG[timeout]}"
    [[ -z "${BARG_ARGV_TABLE[GOOSE_TRIES]}" && -n "${GOOSE_CONFIG[tries]}" ]] \
      && GOOSE_TRIES="${GOOSE_CONFIG[tries]}"
    [[ -z "${BARG_ARGV_TABLE[GOOSE_COOKIES]}" && -n "${GOOSE_CONFIG[cookies]}" ]] \
      && GOOSE_COOKIES="${GOOSE_CONFIG[cookies]}"
    [[ -z "${BARG_ARGV_TABLE[GOOSE_USER_AGENT]}" && -n "${GOOSE_CONFIG[user_agent]}" ]] \
      && GOOSE_USER_AGENT="${GOOSE_CONFIG[user_agent]}"
    [[ -z "${BARG_ARGV_TABLE[GOOSE_RESULT_AMOUNT]}" && -n "${GOOSE_CONFIG[amount]}" ]] \
      && GOOSE_RESULT_AMOUNT="${GOOSE_CONFIG[amount]}"
    [[ -z "${BARG_ARGV_TABLE[GOOSE_RESULT_START]}" && -n "${GOOSE_CONFIG[skip]}" ]] \
      && GOOSE_RESULT_START="${GOOSE_CONFIG[skip]}"
  }

  # shellcheck disable=SC2153
  local query="${GOOSE_QUERY[*]}"

  if ((GOOSE_RESULT_AMOUNT < 1)) || ((GOOSE_RESULT_AMOUNT > 100)); then
    log i 'Invalid amount of results (%s), defaulting to 10' "${GOOSE_RESULT_AMOUNT}"
    GOOSE_RESULT_AMOUNT=10
  fi

  if [ -n "${GOOSE_PRESET}" ]; then
    if [ -z "${preset_file}" ]; then
      log e 'No preset file defined. Add `preset_file: <path>` to ~/.config/_/goose.conf'
      return 1
    fi
    if [ ! -f "${preset_file}" ]; then
      log e 'Failed to load presets: no such file %s' "${preset_file}"
      return 1
    fi
    local preset_format='{{QUERY}}'
    if ! preset_format=$(grep -oP "(?<=${GOOSE_PRESET}: ).*" "${preset_file}"); then
      log e 'Failed to get query from preset: no such preset "%s"' "${GOOSE_PRESET}"
      return 1
    fi
    query="${preset_format//\{\{QUERY\}\}/${query}}"
  fi

  declare -A grequest=()
  grequest['query']="${query}"
  grequest['tries']="${GOOSE_TRIES}"
  grequest['cookies']="${GOOSE_COOKIES}"
  grequest['timeout']="${GOOSE_TIMEOUT}"
  grequest['user_agent']="${GOOSE_USER_AGENT}"

  # google params
  grequest['g_num']="${GOOSE_RESULT_AMOUNT}"
  grequest['g_start']="${GOOSE_RESULT_START}"

  if ! google_search grequest; then
    log e 'Failed to search google'
    return 1
  fi

  if ((GOOGLE_RESULTS == 0)); then
    log i 'There are no results (have you provided valid cookies?)'
    return 1
  fi

  if ((${#GOOSE_LAUNCH_WITH[@]} > 0)); then
    if ! command -v "${GOOSE_LAUNCH_WITH[0]}" &> /dev/null; then
      log e 'Command %s not found or not executable' "${GOOSE_LAUNCH_WITH[0]}"
      return 1
    fi

    placeholder_index=-1
    for i in "${!GOOSE_LAUNCH_WITH[@]}"; do
      if [[ "${GOOSE_LAUNCH_WITH[i]}" == '{}' ]]; then
        placeholder_index="${i}"
        break
      fi
    done

    # index -1 and also index 0 is the command
    if ((placeholder_index < 1)); then
      log i "Launching command..."
      exec "${GOOSE_LAUNCH_WITH[@]}" "${GOOGLE_RESULT_LINKS[@]}"
    fi

    log i "Launching commands..."
    for link in "${GOOGLE_RESULT_LINKS[@]}"; do
      cmd=("${GOOSE_LAUNCH_WITH[@]}")
      cmd[placeholder_index]="${link}"
      log i 'Running: %s' "${cmd[*]}"
      "${cmd[@]}" > /dev/null &
    done

    return
  fi

  if ${GOOSE_JSON_OUTPUT}; then
    local buf=()
    for ((i = 0; i < GOOGLE_RESULTS; i++)); do
      read -r escaped_title < <(str_escape <<< "${GOOGLE_RESULT_TITLES[i]}")
      buf+=("{\"desc\":\"${escaped_title}\",\"url\":\"${GOOGLE_RESULT_LINKS[i]}\"}")
    done
    local json=""
    IFS=, json="${buf[*]}"
    printf "[%s]\n" "${json}"
    return 0
  fi

  for ((i = 0; i < GOOGLE_RESULTS; i++)); do
    local title="${GOOGLE_RESULT_TITLES[i]}"
    [ -n "${title//[!:]/}" ] && title="\"${title//\"/\\\"}\""
    if [[ -t 1 ]] && ! ${GOOSE_MONOCROME}; then
      printf '\x1b[38;2;255;169;140m- desc: \x1b[38;2;255;232;184m%s\n' "${title}"
      printf '  \x1b[38;2;195;79;230murl: \x1b[38;2;189;147;249m%s\x1b[0m\n' "${GOOGLE_RESULT_LINKS[i]}"
    else
      printf -- '- desc: %s\n  url: %s\n' "${title}" "${GOOGLE_RESULT_LINKS[i]}"
    fi
  done
}

# shellcheck disable=SC2034
function google_search {
  declare -n request="${1}"

  if [ -z "${!request[*]}" ]; then
    log e 'No request data available, request skipped'
    return 1
  fi

  if ((${#request[query]} < 1)); then
    log e 'Query cannot be empty'
    return 1
  fi

  declare -A google_url_params=()
  google_url_params['udm']=14                         # Only web search results
  google_url_params['q']="${request[query]}"          # Search Query
  google_url_params['num']="${request[g_num]:-10}"    # Amount of results
  google_url_params['start']="${request[g_start]:-0}" # Start from the N result
  google_url_params['dpf']="${request[g_dpf]:-1}"     # Results page number

  read -r google_req_url < <(url_params google_url_params)
  google_req_url="https://www.google.com/search?${google_req_url:?}"

  local __attempts=0
  local http_codes=()
  local in_error=false
  while true; do
    if [ "${__attempts}" -ge "${request[tries]:-5}" ]; then
      log e 'Stopped after %d failed attempts. Try again later' "${request[tries]:-5}"
      in_error=true
      break
    fi
    ((__attempts++))

    response_body=$(
      curl -Ss "${google_req_url}" --compressed \
        -H 'accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8' \
        -H 'accept-language: en-US,en;q=0.5' \
        -H 'accept-encoding: gzip, deflate' \
        -H 'cache-control: max-age=0' \
        -b "${request[cookies]}" \
        -H 'dnt: 1' \
        -H 'downlink: 8.85' \
        -H 'priority: u=0, i' \
        -H 'referer: https://www.google.com/' \
        -H 'rtt: 100' \
        -H 'sec-ch-prefers-color-scheme: dark' \
        -H 'sec-ch-ua-arch: "x86"' \
        -H 'sec-ch-ua-bitness: "64"' \
        -H 'sec-ch-ua-form-factors: "Desktop"' \
        -H 'sec-ch-ua-mobile: ?0' \
        -H 'sec-ch-ua-model: ""' \
        -H 'sec-ch-ua-platform: "Linux"' \
        -H "user-agent: ${request[user_agent]}" \
        -H 'dnt: 1' \
        -H 'connection: disconnect' \
        -H 'upgrade-insecure-requests: 1' \
        -H 'sec-ch-ua-platform-version: ""' \
        -H 'sec-ch-ua-wow64: ?0' \
        -H 'sec-fetch-dest: document' \
        -H 'sec-fetch-mode: navigate' \
        -H 'sec-fetch-site: same-origin' \
        -H 'sec-fetch-user: ?1' \
        -H 'x-browser-channel: stable' \
        -H 'x-browser-copyright: Copyright 2025 Google LLC. All Rights reserved.' \
        -H 'x-browser-validation: lWZoCd/Ihv9Aa32HuKZ6rlDBoto=' \
        -H 'x-browser-year: 2025' \
        --max-time "${request[timeout]:-5}" \
        --write-out '\n%{http_code}' \
        2> >(sed 's/curl: ([0-9]*)/[INFO]/' >&2)
    )

    local http_code="${response_body: -3}"
    http_codes+=("${http_code}")

    if ((100 <= http_code && http_code <= 199)); then
      log d 'HTTP %s -> Google informative... skipped. %d attempt.' "${http_code}" "${__attempts}"
      continue
    elif ((200 <= http_code && http_code <= 299)); then
      log d 'HTTP %s -> Google successful. %d attempt.' "${http_code}" "${__attempts}"
      if [[ "${response_body}" == *'<script src="https://www.google.com/recaptcha/api.js" async defer></script>'* ]]; then
        log e "HTTP %s -> Google Captcha. Change any of proxy, user-agent, cookies or try again later. %d attempt." "${http_code}" "${__attempts}"
        in_error=true
      fi
      break
    else
      if ((300 <= http_code && http_code <= 399)); then
        log e 'HTTP %s -> Google redirection, try again changing user-agent. %d attempt.' "${http_code}" "${__attempts}"
      elif ((400 <= http_code && http_code <= 499)); then
        log e 'HTTP %s -> Client error, check the data and try again. %d attempt.' "${http_code}" "${__attempts}"
      elif ((500 <= http_code && http_code <= 599)); then
        log e 'HTTP %s -> Server error, try again later. %d attempt.' "${http_code}" "${__attempts}"
      else
        log d 'HTTP %s -> Invalid code. %d attempt.' "${http_code}" "${__attempts}"
        continue
      fi
      in_error=true
    fi
  done

  log d 'Record of HTTP codes [%s]' "${http_codes[*]}"
  ${in_error} && return 1

  mapfile -t GOOGLE_RESULT_TITLES < <(grep -oP '(?<=<br><h3 class="LC20lb MBeuO DKV0Md" id=")[^<]*(?=<)' <<< "${response_body}" | sed 's/^.\{29\}//' | xml_unescape)
  mapfile -t GOOGLE_RESULT_LINKS < <(grep -oP '(?<=><a jsname="UWckNb" href=")[^ ]*(?=")' <<< "${response_body}")

  declare -g GOOGLE_RESULTS=${#GOOGLE_RESULT_LINKS[@]}
  declare -g GOOGLE_RESULT_TITLES
  declare -g GOOGLE_RESULT_LINKS

  return 0
}

main "${@}"
