#!/usr/bin/bash
# ðŸ”— https://github.com/klapptnot/bash.sh
# SPDX-License-Identifier: AGPL-3.0-or-later
# Copyright (c) 2025-present Klapptnot

include barg.sh
include logger.sh

function get_file_hash {
  ls -lh --time-style=full-iso "${SPAWN_WATCH_PATH}" 2> /dev/null | md5sum | cut -d ' ' -f 1
}

function time_parse {
  IFS=':' read -r seconds minutes hours days

  # Just to ensure that the seconds are the correct value
  ((t_sec = (days * 24 * 60 * 60) + (hours * 60 * 60) + (minutes * 60) + seconds))
  ((d = t_sec / 86400, h = (t_sec % 86400) / 3600, m = (t_sec % 3600) / 60, s = t_sec % 60))
  local lll=('s')
  local t_str_a=()
  ((d > 0)) && t_str_a+=("${d} day${lll[1 - (d > 1)]}")
  ((h > 0)) && t_str_a+=("${h} hour${lll[1 - (h > 1)]}")
  ((m > 0)) && t_str_a+=("${m} min${lll[1 - (m > 1)]}")
  ((s > 0)) && t_str_a+=("${s} sec${lll[1 - (s > 1)]}")
  local t_str="${t_str_a[*]}"
  unset -v lll d h m s t_str_a

  printf '%s %s\n' "${t_sec}" "${t_str}"
}

function run_on_change {
  local interval="${1}"
  shift 1

  read -r LAST_HASH < <(get_file_hash)
  log i 'Initial hash: %s' "${LAST_HASH}"

  local argv=()
  for it in "${@}"; do
    [[ "${it}" == -* ]] && argv+=('--')
    argv+=("${it}")
  done

  while true; do
    sleep "${interval}"
    read -r CURRENT_HASH < <(get_file_hash)

    if [ "${CURRENT_HASH}" != "${LAST_HASH}" ]; then
      log info 'Change detected!'
      setsid --fork spawn -r "${argv[@]}" # call this one to restart it
      LAST_HASH="${CURRENT_HASH}"
    fi
  done
}

function spawner {
  sleep "${1:?}" || return
  shift 1

  read -r USER_ID < <(id -u)

  if ${SPAWN_RESTART}; then
    if pgrep -U "${USER_ID}" "${SPAWN_EXEC_LINE[0]}" &> /dev/null; then
      pkill -U "${USER_ID}" --signal SIGKILL "${SPAWN_EXEC_LINE[0]}"
    fi
  fi

  ${SPAWN_GO_FS_ROOT} && {
    cd / &> /dev/null || {
      log e "Failed to change dir to root (/)" && return
    }
  }

  if ${SPAWN_AS_GNOME}; then
    XDG_CURRENT_DESKTOP=GNOME XDG_SESSION_DESKTOP=gnome \
      exec "${@}"
  else
    exec "${@}"
  fi
}

function main {
  local _epilogs=(
    "{acc}Note:\x1b[0m"
    "  \`-a/--run-at\` format is: seconds:minutes:hours:days, default: 0:0:0:0"
    "  \`-a/--run-at\` with -w/--watch-file format is the same as sleep command"
  )
  barg::parse "${@}" << BARG
  #[always]
  meta {
    summary: "Command line tool to spawn processes"
    spare_args_var: 'SPAWN_EXEC_LINE'
    epilog_lines: '_epilogs'
    spare_args_required: true
    help_enabled: true
    show_defaults: true
  }

  r/restart :flag => SPAWN_RESTART "Restart the process if it is already running"
  c/cwd-root :flag => SPAWN_GO_FS_ROOT "Change PWD / to prevent locking CWD"
  k/keep :flag true => SPAWN_IN_BACKGROUND "Do not detach from caller terminal"
  w/watch-file :str => SPAWN_WATCH_PATH "Run when file is updated, --run-at for interval"
  a/run-at :str "" => SPAWN_AT_TIME "Time to wait before spawning the process"
  g/as-gnome :flag => SPAWN_AS_GNOME "Launch the process as a GNOME session"
  u/uwsm :flag => SPAWN_WITH_UWSM "Spawn process using uwsm"
  L/logger :int => SPAWN_LOGGER_LEVEL "Logging level"
BARG
  if [[ -n "${BARG_ARGV_TABLE[SPAWN_WATCH_PATH]}" && ! -e "${SPAWN_WATCH_PATH}" ]]; then
    barg::exit_msg "Directory not found" "Arg for '-d/--dir-file' must be an existing file or folder"
  fi
  barg::unload

  log::setup "${SPAWN_LOGGER_LEVEL}"

  if ${SPAWN_WITH_UWSM} && ! command -v uwsm &> /dev/null; then
    log e 'The command uwsm is not an executable'
    return 1
  fi

  if ! command -v "${SPAWN_EXEC_LINE[0]}" &> /dev/null; then
    log e 'The command %s is not an executable' "${SPAWN_EXEC_LINE[0]}"
    return 1
  fi

  ${SPAWN_WITH_UWSM} && {
    SPAWN_EXEC_LINE=("uwsm" "app" "--" "${SPAWN_EXEC_LINE[@]}")
    ((SPAWN_EXEC_LINE_COUNT += 3))
  }

  ((SPAWN_EXEC_LINE_COUNT > 1)) && printf -v cmd_line ' %q' "${SPAWN_EXEC_LINE[@]:1}"
  local cmd_line="${SPAWN_EXEC_LINE[0]}${cmd_line}"

  log d 'Command to run: %s' "${cmd_line}"

  [ -n "${SPAWN_WATCH_PATH}" ] && {
    run_on_change "${SPAWN_AT_TIME:-0.5}" "${SPAWN_EXEC_LINE[@]}"
    return
  }

  read -r t_sec t_str < <(time_parse <<< "${SPAWN_AT_TIME:-0:0:0:0}")

  if ((t_sec > 0)); then
    if ${SPAWN_RESTART}; then
      log i 'Process will be restarted in %s' "${t_str[*]}"
    else
      log i 'Process will be spawned in %s' "${t_str[*]}"
    fi
  fi

  ${SPAWN_IN_BACKGROUND} || {
    spawner "${t_sec}" "${SPAWN_EXEC_LINE[@]}"
    return
  }
  spawner "${t_sec}" "${SPAWN_EXEC_LINE[@]}" &> /dev/null &
}

main "${@}"
